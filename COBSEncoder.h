/* * COBSEncoder.h *  * Copyright 1997-1999, 2004, 2007, Stuart Cheshire <http://www.stuartcheshire.org/> *  * This is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * See <http://www.gnu.org/copyleft/lesser.html> *  * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU * Lesser General Public License for more details. *  *  * INTRODUCTION * * When sending messages over a byte stream, such as an RS232 serial port * or a TCP connection, a way is needed to mark message boundaries. * * Usually the best way to do this is to use a framing marker character * which is guaranteed to never appear in the message body. This way, * if synchronization is lost, the receiver just needs to hunt for the * next framing marker character to locate the start of the next message. * * If the message body is allowed to contain any byte values, then byte * stuffing must be used first to eliminate any occurrences of the framing * value from the message body, otherwise this framing scheme won't work * reliably. Conventional byte stuffing (e.g. as used by SLIP or PPP) can * double the size of the data, which is not very good. In contrast, COBS * guarantees that the size of the byte stuffed data is at worst no more than * 0.5% larger than the input data, rounded up to the next integer value, and * in some cases it is smaller. For example, for a message that is 160 bytes * long, COBS encoding guarantees to add at most 0.005*160 = 0.8 bytes of * overhead. Since COBS can't can't encode a fraction of a byte, this means a * maximum byte stuffing overhead of one byte. After adding the one-byte * framing marker, this means that a 160-byte message can be sent using at * most 162 bytes over a serial byte-stream connection. A 1000-byte message * can be sent using at most 1006 bytes. This is a big improvement over SLIP * or PPP framing, which could require as many as 2001 bytes for a 1000-byte * message. *  * By default COBS eliminates zeroes from the message body so that zero may * be used as the framing marker, but the message may be transformed so that * any desired value is eliminated by editing Tx(X) and Rx(X) in COBSEncoder.c *  * For a thorough description of Consistent Overhead Byte Stuffing, see * See <http://www.stuartcheshire.org/#Pubs> *  * * HOW TO USE THESE API ROUTINES: *  * Both COBSEncode and COBSDecode can be used in one-shot or pipeline mode. * * In one-shot mode, you hand the call a block of data, and it hands back * a block of encoded (or decoded) data. * * In pipeline mode, you hand it a partial block of data, and it hands back * a partial block of encoded data, with an indication of which part of the * encoded data is finalized and ready to ship over the network connection * and which part of the data is still in flux and shouldn't be shipped yet. */extern void COBSEncode  (const unsigned char *ptr, unsigned int length,                         unsigned char **dp, unsigned char **state_ptr);/* * char *dst = &outputbuffer; * unsigned char *state = NULL; * COBSEncode(ptr, length, &dst, &state); *  * COBSEncode stuffs 'length' bytes of data from the buffer 'ptr', writing * the output to 'dp', and advancing 'dp' by the number of bytes written. * * COBSEncode does *not* add the framing marker(s) before and/or after * the encoded message -- adding the necessary framing marker(s) before * transmission is the caller's responsibility. * * The size of the output buffer must be large enough to accommodate * the encoded data, which in the worst case may expand by almost 0.5%. * The exact amount of safety margin required can be calculated using * (1+length)/207, rounded *up* to the next whole number of bytes. * (Alternatively, that's 1+(length/207), rounded down.) * E.g. for a 1K packet, the output buffer needs to be 1K + 5 bytes * to be certain of accommodating worst-case packets. * * In one-shot mode, pass NULL for &state. * * In pipeline mode, state is an "unsigned char *" pointer which must be * initially set to NULL prior to the first call. On exit from the first and * subsequent calls, 'state' indicates how much data has been finalized; * everything up to but not including 'state' may be shipped over the wire; * everything from 'state' onwards *may* change as more bytes are added to * the message. The value of 'state' must be preserved and passed back in on * subsequent calls, so that COBSEncode can resume building the partial * message properly. * * The result of calling COBSEncode is always a validly formed COBS message; * COBSEncode retains the ability to graft new data onto the end of an * existing message, modifying it as necessary, but the intermediate results * are always legal messages. This means that there is no need to explicitly * 'close' or 'finalize' a message; as soon as the last partial block has been * added to a message, the message is valid, complete, and ready to send. *  * An unbounded output buffer is *not* required to support unbounded messages. * After calling COBSEncode, all bytes up to but not including 'state' may be * shipped over the wire. Having done this, the remaining unsent bytes can be * shifted to the start of the output buffer using memmove; all that is * required is that 'dp' and 'state' are offset by the same amount so that * they still point to the right relative locations in the unsent output data. * Double-buffered operation is also possible, where the unsent bytes can be * moved to the start of the alternate buffer, provided that 'dp' and 'state' * are similarly adjusted. Since 'state' indicates the first unsent byte, * this means that 'state' should end up pointing to the start of the data * in the new buffer, and 'dp' should be 'state' plus the number of unsent * bytes. The number of unsent bytes that need to be moved will never be more * than 207. A working buffer of 1K (or larger) is recommended, so that a * reasonable number of finished bytes can be sent each time, relative to * the number of bytes that may have to be copied. */extern int  COBSDecode  (const unsigned char **sp, unsigned int srclength,                         unsigned char **dp, unsigned int dstlength,                         unsigned short *state_ptr);/* * unsigned char *src = &inputbuffer; * unsigned char *dst = &outputbuffer; * unsigned short state = 0; * COBSDecode(&src, srclength, &dst, dstlength, &state) *  * COBSDecode decodes at most 'srclength' bytes of data from the buffer 'src', * writing at most 'dstlength' bytes of output to 'dst'. The variables 'src' * and 'dst' are advanced by the number of bytes read and written, * respectively. If 'dst' is NULL on exit, the message was invalid. *  * Framing marker(s) before and/or after the encoded message data are not * necessary. However, if there is a framing marker at the end of the message, * COBSDecode will stop decoding when it encounters it, and return 1 (true). * If COBSDecode returns 0 (false) and you were expecting it to find a framing * marker, then subsequent calls must be issued with more source data and/or * more output space until the whole message has been fully decoded. *  * In one-shot mode, pass NULL for &state. *  * In pipeline mode, state is a 16-bit word which must be initially set to * zero prior to the first call. The value of 'state' must be preserved, and * its address passed back in on subsequent calls, so that COBSDecode can * correctly resume decoding a partially completed message. *  * Pipeline mode may occur either because the currently available source data * is exhausted before having decoded a complete message, or because the * available destination space is exhausted before having decoded a complete * message. Both modes -- source-constrained and destination-constrained -- * are supported and work correctly. (This is in contrast to COBSEncode, which * only supports source-constrained; the caller must guarantee that there is * enough output space for COBSEncode.) */extern int  COBSDecode_P(const unsigned char **sp, const unsigned char *end,                         unsigned char **dp, const unsigned char *lim,                         unsigned short *state_ptr);/* * The COBSDecode_P variant uses limit pointers instead of srclength and * dstlength. */
/* * COBSEncoder.c *  * Copyright 1997-1999, 2004, 2007, Stuart Cheshire <http://www.stuartcheshire.org/> *  * This is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * See <http://www.gnu.org/copyleft/lesser.html> *  * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU * Lesser General Public License for more details. * * For API documentation see COBSEncoder.h */#include "COBSEncoder.h"typedef unsigned char u_char;typedef unsigned short u_short;#ifndef	NULL#define	NULL 0#endif/* This enum defines the basic code set used by this COBS variant: * It has explicit encodings for: * - a run of 0 to 206 non-zero bytes, followed by a single zero byte * - a run of 0 to 30 non-zero bytes, followed by a pair of zero bytes * - a run of 3 to 15 zero bytes * - a long run (207 bytes) containing no zero bytes at all * All possible data patterns can be expressed in terms of these primitives */typedef enum	{	Framing      = 0x00,   /* Unused (framing character placeholder)    */	DiffZero     = 0x01,   /* Range 0x01 - 0xCF:                        */	DiffZeroMax  = 0xCF,   /* n-1 explicit characters plus a zero       */	Diff         = 0xD0,   /* 207 explicit characters, no implicit zero */	Resume       = 0xD1,   /* Unused (resume preempted packet)          */	Reserved     = 0xD2,   /* Unused (reserved for future use)          */	Run3Zero     = 0xD3,   /* Range 0xD3 - 0xDF:                        */	RunZeroMax   = 0xDF,   /* 3-15 zeroes                               */	Diff2Zero    = 0xE0,   /* Range 0xE0 - 0xFE:                        */	Diff2ZeroMax = 0xFE,   /* 0-30 explicit characters plus two zeroes  */	Error        = 0xFF    /* Unused (PPP LCP re-negotiation)           */	} StuffingCode;/* These macros examine just the top three/four bits of the code byte */#define isDiff2Zero(X) (((X) & 0xE0) == (Diff2Zero & 0xE0))#define isRunZero(X)   (((X) & 0xF0) == (Run3Zero  & 0xF0))/* Convert from single-zero code to corresponding double-zero code    *//* To convert from single-zero to double-zero code add ConvertZP      *//* To convert from double-zero back to single-zero subtract ConvertZP */#define ConvertZP (Diff2Zero - DiffZero)/* Highest single-zero code with a corresponding double-zero code     */#define MaxConvertible (Diff2ZeroMax - ConvertZP)/* * Perform input/output mapping, if necessary * The basic COBS algorithm eliminates zeroes from the data. * If you need to eliminate some other framing value (e.g. ASCII CR) * then a simple substitution mapping can achieve this. * For example, if you XOR the data with 13, then since the COBS-encoded * data has no zeroes, the mapped data will have no 13s: * #define Tx(X) ((X) ^ 13) * #define Rx(X) ((X) ^ 13) * Caution: Take care not to write macros that may generate multiple * references, or expressions like "Rx(*ptr++)" will generate an * unintended double-increment. Consider using inline functions, * if your compiler is smart enough to implement them efficiently.*/#define Tx(X) (X)#define Rx(X) (X)/* * COBSEncode stuffs "length" bytes of data from the buffer "ptr", writing * the output to "*dp", and incrementing "*dp" by the number of bytes written. * The size of the output buffer must be large enough to accommodate * the encoded data, which in the worst case may expand by almost 0.5%. * The exact amount of safety margin required can be calculated using * (1+length)/207, rounded *up* to the next whole number of bytes. * (Alternatively, that's 1+(length/207), rounded down.) * E.g. for a 1K packet, the output buffer needs to be 1K + 5 bytes * to be certain of accommodating worst-case packets. */#define FinishBlock(X) (*code_ptr = Tx(X), code_ptr = dst++, code = DiffZero)void COBSEncode(const u_char *ptr, unsigned int length,                      u_char **dp, u_char **code_ptr_ptr)	{	const u_char *end      = ptr + length;	u_char       *dst      = *dp;	u_char       *code_ptr = NULL;	u_char       code;	if (code_ptr_ptr) code_ptr = *code_ptr_ptr;	/* Recover state from last call, if applicable */	if (code_ptr && code_ptr < dst) code = Rx(*code_ptr);	else { code_ptr = dst++; code = DiffZero; }	while (ptr < end)		{		u_char c = *ptr++;  /* Read the next character */		if (c == 0)         /* If it's a zero, do one of these operations */			{			if      (isRunZero(code) && code < RunZeroMax) code++;			else if (code == Diff2Zero)                    code = Run3Zero;			else if (code <= MaxConvertible)               code += ConvertZP;			else                                           FinishBlock(code);			}		else                /* else, non-zero; do one of these operations */			{			if      (isDiff2Zero(code)) FinishBlock(code - ConvertZP);			else if (code == Run3Zero)  FinishBlock(Diff2Zero);			else if (isRunZero(code))   FinishBlock(code-1);			*dst++ = Tx(c);			if      (++code == Diff)    FinishBlock(code);			}		}	*code_ptr = Tx(code);		// Fill in the code byte	// And record where we put it, for possible later update	if (code_ptr_ptr) *code_ptr_ptr = code_ptr;	*dp = dst;	}/* * COBSDecode decodes "srclength" bytes of data from the * buffer "*sp", writing the output to "*dp". "*sp" and "*dp" are * advanced by the number of bytes read and written, respectively. * If COBSDecode returns true then an entire message has been decoded, * otherwise subsequent calls must be issued with more source data * and/or more output space in order to decode the remaining data. * On the first call code_ptr should be set to point to a 16-bit word * initialized to zero, and on subsequent calls the same code_ptr * should be passed in to allow the routine to correctly resume * decoding a partially completed message. * If "*dp" is set to NULL then the source data was invalid. * The COBSDecode_P variant uses limit pointers instead of * srclength and dstlength */int COBSDecode_P(const u_char **sp, const u_char *end,                       u_char **dp, const u_char *lim, u_short *code_ptr)	{	const u_char *src = *sp;				// Get source pointer	u_char       *dst = *dp;				// Get source pointer	int c = 0;		// Number of non-zero characters we need to read	int z = 0;		// Number of zero bytes we need to append afterwards	// If we have saved state, retrieve 'c' and 'z' values from it	if (code_ptr) { c = *code_ptr & 0xFF; z = *code_ptr >> 8; }	while (1)		{		// 1. Copy any non-zero characters we need to read		while (c > 0 && src < end && dst < lim)			{			const u_char x = Rx(*src++);			c--;			if (x == Framing) goto err; else *dst++ = x;			}		if (c) break;	// If not finished, bail out for now		// 2. Append any necessary zero bytes, holding the last one		while (z > 1 && dst < lim) { z--; *dst++ = 0; }		if (z > 1) break;	// If not finished, bail out for now		if (src >= end) break;				// No more source data; bail out		// 3. The last zero of every message is always a phantom one.		// If we have more source data, and it's not the framing marker		// then we're not at the end yet, so this is a real zero, so write it.		if (z > 0 && Rx(*src) != Framing)	// Add one more zero?			{			if (dst >= lim) break;			// If no space, bail out			else *dst++ = 0;			}				// 4. Fetch next code byte and decode it into 'c' and 'z' values		c = Rx(*src++);		if (c == Error || c == Resume || c == Reserved) goto err;		else if (c == Framing)    { z = 0;       goto eom;  }		else if (c == Diff)       { z = 0;       c--;       }		else if (isRunZero(c))    { z = c & 0xF; c = 0;     }		else if (isDiff2Zero(c))  { z = 2;       c &= 0x1F; }		else                      { z = 1;       c--;       }		}	// Save away the 'c' and 'z' values for when we return	if (code_ptr) *code_ptr = ((u_short)z) << 8 | c;	*sp = src; *dp = dst; return(0);err:dst = NULL;eom:if (code_ptr) *code_ptr = 0;	*sp = src; *dp = dst; return(1);	}int COBSDecode(const u_char **sp, unsigned int srclength,                     u_char **dp, unsigned int dstlength, u_short *code_ptr)	{	return(COBSDecode_P(sp, *sp + srclength, dp, *dp + dstlength, code_ptr));	}